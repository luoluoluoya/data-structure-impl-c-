//
// Created by 47302 on 2020/5/23.
//

#pragma once

//基于BST实现RedBlack
#include "../BST/BST.h"


/**
 平衡二叉搜索树的形式多样，且各具特色。比如，伸展树实现简便、无需修改节点结构、分摊复杂度低，但可惜最坏情况下的单次操作需要线性时间，
 故难以适用于核电站、医院等对可靠性和稳定性要求极高的场合。反之，AVL树尽管可以保证最坏情况下的单次操作速度，但需在节点中嵌入平衡因子等标识；
 更重要的是，删除操作之后的重平衡可能需做多达 logn 次旋转，从而频繁地导致全树整体拓扑结构的大幅度变化。
 红黑树即是针对后一不足的改进。通过为节点指定颜色，并巧妙地动态调整，红黑树可保证：在每次插入或删除操作之后的重平衡过程中，
 全树拓扑结构的更新仅涉及常数个节点。尽管最坏情况下需对多达\Omage(logn)个节点重染色，但就分摊意义而言仅为O(1)个

 红黑树的适度平衡：任一节点左、右子树的高度，相差不得超过两倍

 统一地引入n + 1个外部节点，以保证原树中每一节点（现称作内部节点）的左、右孩子均非空 （真二叉树）

 由红、黑两色节点组成的二叉搜索树若满足以下条件，即为红黑树
    1. 树根始终为黑色
    2. 外部节点均为黑色. (红节点均为内部节点，且其父节点及左、右孩子必然存在)
    3. 其余节点若为红色，则其孩子节点必为黑色. (红节点之父必为黑色，因此树中任一通路都不含相邻的红节点)
    4. 从任一外部节点到根节点的沿途，黑节点的数目相等.

    在从根节点通往任一节点的沿途，黑节点都不少于红节点。除去根节点本身，沿途所经黑节点的总数称作该节点的黑深度（black depth）.
 根节点的黑深度为0，其余依此类推。故条件(4)亦可等效地理解和描述为“所有外部节点的黑深度统一”.
    在从任一节点通往其任一后代外部节点的沿途，黑节点的总数亦必相等。除去（黑色）外部节点，沿途所经黑节点的总数称作该节点的黑高度（black height）。
 如此，所有外部节点的黑高度均为0，其余依此类推。特别地，根节点的黑高度亦称作全树的黑高度，在数值上与外部节点的黑深度相等。

 红黑树与B树：（再看见红黑树时， 请你心里有点B树）
        具体地，自顶而下逐层考查红黑树各节点。每遇到一个红节点，都将对应的子树整体提升一层，从而与其父节点（必黑）水平对齐，
    二者之间的联边则相应地调整为横向。如此转换之后，横向边或向左或向右，但由红黑树的条件(3)，同向者彼此不会相邻；即便不考虑联边的左右方向，
    沿水平方向相邻的边至多两条（向左、右各一条），涉及的节点至多三个（一个黑节点加上零到两个红节点）。此时，若将原红黑树的节点视作关键码，
    沿水平方向相邻的每一组（父子至多三个）节点即恰好构成4阶B-树的一个节点。
        红黑树的每一节点都对应于后者的一个关键码。通往黑节点的边，对黑高度有贡献，并在(2,4)-树中得以保留；通往红节点的边对黑高度没有贡献,在(2,4)-
    树中对应于节点内部一对相邻的关键码。
        (2,4)-树中的每个节点应包含且仅包含一个黑关键码，同时红关键码不得超过两个。而且，若某个节点果真包含两个红关键码，则黑关键码的位置必然居中
 平衡性:
        尽管红黑树不能如完全树那样可做到理想平衡，也不如AVL树那样可做到较严格的适度平衡，但其高度仍控制在最小高度的两倍以内，
    从渐进的角度看仍是O(logn)，依然保证了适度平衡这正是红黑树可高效率支持各种操作的基础。
===================================
 因新节点的引入，而导致父子节点同为红色的此类情况，称作“双红”：
     将x的父亲与祖父分别记作p和g。既然此前的红黑树合法，故作为红节点p的父亲，g必然在且为黑色。g作为内部节点，其另一孩子（即p的兄弟、x的叔父）也必然存在，将其记作u。
     双红修正（RR-1）: (考查u为黑色的情况)
        B树: 【x, p, g】是一个包含两个两个相邻红关键码的超级节点， 此时，x的兄弟、两个孩子的黑高度，均与u相等。只需要将黑色节点居中即可。 （令黑色关键码与紧邻的红色关键码互换颜色）
        红黑树: 这等效于按中序遍历次序，对节点x、p和g及其四棵子树，做一次局部“3 + 4”重构。 (将由红转黑的关键码成为新的根节点， 拓扑结构发生一次等价变换)
        不难验证，如此调整之后，局部子树的黑高度将复原，这意味着全树的平衡也必然得以恢复。同时，新子树的根节点为黑色，也不致引发新的双红现象。至此，整个插入操作遂告完成。
    双红修正（RR-2）: (考查节点u为红色)
        B树： [x, p, g, u] 为（2，4）树的一个超级节点。 此时，u的左、右孩子非空且均为黑色，其黑高度必与x的兄弟以及两个孩子相等。 超级节点发生上溢。（取居中元素，上溢至父节点， 当前节点恢复）
            1. 上溢节点需染色为红节点后执行上溢。（g转化为红色）
            2. 上溢执行完成后， 当前超级节点的黑高度需保持不变（p，u转化为黑色）
        不难验证，如此调整之后局部子树的黑高度复原。然而，子树根节点g转为红色之后，有可能在更高层再次引发双红现象。从B-树的角度来看，
       对应于在关键码g被移出并归入上层节点之后，进而导致上层节点的上溢，即上溢的向上传播。若果真如此，可以等效地将g视作新插入的节点，
       同样地分以上两类情况如法处置。请注意，每经过一次这样的迭代，节点g都将在B-树中（作为关键码）上升一层，而在红黑树中存在双红缺陷
       的位置也将相应地上升两层，故累计至多迭代O(logn)次。特别地，若最后一步迭代之后导致原树根的分裂，并由g独立地构成新的树根节点，
       则应遵照红黑树条件(1)的要求，强行将其转为黑色如此，全树的黑高度随即增加一层。
        红黑树： 对节点g和p，u的重染色过程， 可能持续log（n）次，但不涉及拓扑结构的改变。
===================================
 红黑树删除操作：删除节点之后， 后两个元素的性质不一定能得到满足
    考察树删除操作本身：
        1. 待删除元素至多存在一个子树： 直接另子树的根节点接替当前节点位置， 完成删除
        2. 待删除元素存在左右子树时： 在其右子树的最左处找到其直接后继， 替换两则数据， 待删除元素更替为其后继元素。且当前待删除元素不存在左子树。（情况1）
    So： 待删除节点至多只存在一棵子树 （该子树根节点即位其 ·接替节点·）
    假设： 待删除节点 x， x孩子节点 w，r; x父节点 p， x祖父节点 g， x的兄弟节点u； （不失一般性， 令w为黑色外部节点）
        1. x为红色， 直接执行删除， r接替之
        2. x为黑色
            2.1 r红色， 将其反转为黑色，接替之
            2.2 r黑色， 双黑问题

 双黑问题修正： （x为黑色， r为黑色+）
    B树视角分析双黑问题： 既然节点x的另一孩子w = NULL，节点x被删除之后的情况，可以等效地理解为：关键码x原所属的节点发生下溢导致的性质破坏；
    双黑修正（BB-1）： 兄弟节点u为黑色， 且其存在一个红孩子；
        B树看来： 下溢节点的兄弟节点足够充裕， 可从父节点出发转借一个兄弟节点的节点
        红黑树：对 【u, p, x】执行一次 ‘3+4’重构， 和重染色 （u更新为p的颜色， p转化为黑色， u的红子节点转化为黑色）

    双黑修正（BB-2-R）：节点u及其两个孩子均为黑色时，视节点p为红
        B树： 下溢节点的兄弟节点濒临下溢， 无法从父节点出发转借一个兄弟节点的节点。此时只能将父节点下溢对子节点进行合并（ （2，4）节点下溢时为空节点， 则等同于将p与u合并 ）
            节点p所在的超级节点元素充足， 剥离节点p之后不会发生下溢。 算法终止。
        红黑树： 节点u与p合并， 等同于将 p转化为黑色， u变为红色； （互换颜色）

    双黑修正（BB-2-B）: 节点u及其两个孩子均为黑色时，视节点p为黑
        B树： 下溢节点的兄弟节点濒临下溢， 无法从父节点出发转借一个兄弟节点的节点。此时只能将父节点下溢对子节点进行合并（ （2，4）节点下溢时为空节点， 则等同于将p与u合并 ）
            节点p所在的超级节点在剥离节点p之后， 当前合并的节点完成修复， 但父节点会发生下溢。 算法向上传播一层。幸运的是，尽管此类情况可能持续发生，下溢的位置也必然不断上升，故至多迭代O(logn)次后必然终止。
        红黑树： 节点u与p合并， 等同于将u变为红色；

     双黑修正（BB-3）:  节点u为红色的情况
        节点u的两个子节点必定为黑色。 对 p 执行一次旋转操作。 令 u 成为新子树根节点。 则此时， u 的 一黑子节点必定成为 p 的一子节点。 （BB-1, BB-2-R）
        红黑树： 等同于对 【u，p， x】 执行一次 ‘3+4’重构和常数次从染色操作

    纵览各种情况，不难确认：一旦在某步迭代中做过节点的旋转调整，整个修复过程便会随即完成。因此与双红修正一样，双黑修正的整个过程，也仅涉及常数次的拓扑结构调整操作。
    这一有趣的特性同时也意味着，在每此插入操作之后，拓扑联接关系有所变化的节点绝不会超过常数个。 这一点与AVL树（的删除操作）完全不同，也是二者之间最本质的一项差异。
===================================
    超级节点内部颜色的变化与树拓扑结构变化的关系
        【红1红2黑3】 ==染色==》 【红1黑2红3】  （水平不变，上下可乱）
        经染色变化， 节点2的拓扑位置更新到节点3处。节点3成为节点2的子节点
 */


//RedBlack树模板类
template<typename T>
class RedBlack : public BST<T> {
protected:
    void solveDoubleRed(BinNodePosi(T)x);   //双红修正
    void solveDoubleBlack(BinNodePosi(T)x); //双黑修正
    int updateHeight(BinNodePosi(T)x);      //更新节点x的高度
public:
    BinNodePosi(T)insert(const T &e);   //插入（重写）
    bool remove(const T &e);             //删除（重写）
    //BST::search()等其余接口可直接沿用
};

#include "redblack.cpp"


